import axios from 'axios';
import { ScrapingConfig, Company } from '@/types';
import { supabase } from '@/config/database';
import { RateLimiterMemory } from 'rate-limiter-flexible';
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/google-maps.log' }),
    new winston.transports.Console()
  ]
});

const rateLimiter = new RateLimiterMemory({
  points: 100, // Number of requests
  duration: 86400, // Per 24 hours (Google Maps API daily limit)
});

export class GoogleMapsService {
  private apiKey: string;
  private baseUrl = 'https://maps.googleapis.com/maps/api/place';

  constructor() {
    this.apiKey = process.env.GOOGLE_MAPS_API_KEY!;
    if (!this.apiKey) {
      throw new Error('Google Maps API key is required');
    }
  }

  async searchBusinesses(config: ScrapingConfig): Promise<Company[]> {
    try {
      await rateLimiter.consume('google-maps');
      
      const query = this.buildSearchQuery(config);
      const places = await this.searchPlaces(query, config);
      const companies: Company[] = [];

      for (const place of places) {
        try {
          const placeDetails = await this.getPlaceDetails(place.place_id);
          const company = this.mapPlaceToCompany(placeDetails);
          
          if (company && this.isValidBusiness(company, config)) {
            companies.push(company);
            await this.saveCompany(company);
            logger.info(`Scraped business: ${company.name}`);
          }
        } catch (error) {
          logger.error(`Error processing place ${place.place_id}:`, error);
        }
      }

      return companies;
    } catch (error) {
      logger.error('Error searching businesses:', error);
      throw error;
    }
  }

  private buildSearchQuery(config: ScrapingConfig): string {
    let query = '';
    
    if (config.business_type) {
      query += config.business_type + ' ';
    }
    
    query += `in ${config.location}`;
    return query;
  }

  private async searchPlaces(query: string, config: ScrapingConfig) {
    const response = await axios.get(`${this.baseUrl}/textsearch/json`, {
      params: {
        query,
        key: this.apiKey,
        radius: config.radius || 50000,
        type: 'establishment'
      }
    });

    if (response.data.status !== 'OK') {
      throw new Error(`Google Places API error: ${response.data.status}`);
    }

    let results = response.data.results || [];
    
    if (config.max_results) {
      results = results.slice(0, config.max_results);
    }

    // Filter out chains if requested
    if (config.exclude_chains) {
      results = results.filter((place: any) => {
        const name = place.name.toLowerCase();
        const chains = ['mcdonald', 'burger king', 'subway', 'starbucks', 'kfc', 'pizza hut', 'domino'];
        return !chains.some(chain => name.includes(chain));
      });
    }

    return results;
  }

  private async getPlaceDetails(placeId: string) {
    await rateLimiter.consume('google-maps');
    
    const response = await axios.get(`${this.baseUrl}/details/json`, {
      params: {
        place_id: placeId,
        key: this.apiKey,
        fields: 'place_id,name,formatted_address,formatted_phone_number,website,rating,business_status,types,reviews'
      }
    });

    if (response.data.status !== 'OK') {
      throw new Error(`Place Details API error: ${response.data.status}`);
    }

    return response.data.result;
  }

  private mapPlaceToCompany(place: any): Company | null {
    if (!place.name || place.business_status !== 'OPERATIONAL') {
      return null;
    }

    return {
      id: '', // Will be generated by database
      name: place.name,
      website: place.website || null,
      email: null, // Will be extracted later
      phone: place.formatted_phone_number || null,
      address: place.formatted_address || null,
      category: place.types?.[0] || null,
      rating: place.rating || null,
      scraped_content: JSON.stringify({
        place_id: place.place_id,
        types: place.types,
        reviews: place.reviews?.slice(0, 3) // Store first 3 reviews for context
      }),
      scraped_at: new Date(),
      created_at: new Date(),
      updated_at: new Date()
    };
  }

  private isValidBusiness(company: Company, config: ScrapingConfig): boolean {
    // Skip businesses without websites (harder to extract emails)
    if (!company.website) {
      return false;
    }

    // Skip if business name is too generic
    const genericNames = ['unnamed', 'business', 'company', 'store'];
    if (genericNames.some(generic => company.name.toLowerCase().includes(generic))) {
      return false;
    }

    return true;
  }

  private async saveCompany(company: Company): Promise<void> {
    try {
      // Check if company already exists by website or name+address
      const { data: existing } = await supabase
        .from('companies')
        .select('id')
        .or(`website.eq.${company.website},and(name.eq.${company.name},address.eq.${company.address})`)
        .single();

      if (existing) {
        logger.info(`Company already exists: ${company.name}`);
        return;
      }

      const { error } = await supabase
        .from('companies')
        .insert({
          name: company.name,
          website: company.website,
          email: company.email,
          phone: company.phone,
          address: company.address,
          category: company.category,
          rating: company.rating,
          scraped_content: company.scraped_content,
          scraped_at: company.scraped_at?.toISOString()
        });

      if (error) {
        throw error;
      }

      // Update analytics
      await this.updateAnalytics('companies_scraped', 1);
    } catch (error) {
      logger.error(`Error saving company ${company.name}:`, error);
      throw error;
    }
  }

  private async updateAnalytics(metric: string, value: number): Promise<void> {
    const { error } = await supabase
      .from('analytics')
      .insert({
        metric_name: metric,
        value,
        date: new Date().toISOString().split('T')[0]
      });

    if (error) {
      logger.error(`Error updating analytics for ${metric}:`, error);
    }
  }

  async getScrapingStats(): Promise<any> {
    const { data, error } = await supabase
      .from('companies')
      .select('scraped_at, created_at')
      .not('scraped_at', 'is', null);

    if (error) {
      throw error;
    }

    const today = new Date().toISOString().split('T')[0];
    const thisWeek = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

    return {
      total: data.length,
      today: data.filter(c => c.scraped_at?.startsWith(today)).length,
      thisWeek: data.filter(c => c.scraped_at && c.scraped_at >= thisWeek).length,
      lastScraped: data.length > 0 ? Math.max(...data.map(c => new Date(c.scraped_at!).getTime())) : null
    };
  }
}